{"/home/travis/build/npmtest/node-npmtest-openid-connect/test.js":"/* istanbul instrument in package npmtest_openid_connect */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-openid-connect/lib.npmtest_openid_connect.js":"/* istanbul instrument in package npmtest_openid_connect */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_openid_connect = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_openid_connect = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-openid-connect/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-openid-connect && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_openid_connect */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_openid_connect\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_openid_connect.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_openid_connect.rollup.js'] =\n            local.assetsDict['/assets.npmtest_openid_connect.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_openid_connect.__dirname + '/lib.npmtest_openid_connect.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-openid-connect/node_modules/openid-connect/index.js":"/**\n * index.js\n * OpenIDConnect provider\n * Based on OAuth 2.0 provider by Amir Malik\n *\n * @author Agust√≠n Moyano\n */\n\nvar EventEmitter = require('events').EventEmitter,\nquerystring = require('querystring'),\n//serializer = require('serializer'),\n//hashlib = require('hashlib2'),\nmodelling = require('modelling'),\nsailsRedis = require('sails-redis'),\ncrypto = require('crypto'),\n_ = require('lodash'),\nextend = require('extend'),\nurl = require('url'),\nQ = require('q'),\njwt = require('jwt-simple'),\nutil = require(\"util\"),\nbase64url = require('base64url'),\ncleanObj = require('clean-obj');\n\n\nvar defaults = {\n        login_url: '/login',\n        consent_url: '/consent',\n        scopes: {\n            openid: 'Informs the Authorization Server that the Client is making an OpenID Connect request.',\n            profile:'Access to the End-User\\'s default profile Claims.',\n            email: 'Access to the email and email_verified Claims.',\n            address: 'Access to the address Claim.',\n            phone: 'Access to the phone_number and phone_number_verified Claims.',\n            offline_access: 'Grants access to the End-User\\'s UserInfo Endpoint even when the End-User is not present (not logged in).'\n        },\n        policies:{\n            loggedIn: function(req, res, next) {\n                if(req.session.user) {\n                    next();\n                } else {\n                    var q = req.parsedParams?req.path+'?'+querystring.stringify(req.parsedParams):req.originalUrl;\n                    res.redirect(this.settings.login_url+'?'+querystring.stringify({return_url: q}));\n                }\n            },\n        },\n        adapters: {\n            redis: sailsRedis\n        },\n        connections: {\n            def: {\n                adapter: 'redis'\n            }\n        },\n        models: {\n                user: {\n                    identity: 'user',\n                    connection: 'def',\n                    schema: true,\n                    policies: 'loggedIn',\n                    attributes: {\n                        name: {type: 'string', required: true, unique: true},\n                        given_name: {type: 'string', required: true},\n                        middle_name: 'string',\n                        family_name: {type: 'string', required: true},\n                        profile: 'string',\n                        email: {type: 'string', email: true, required: true, unique: true},\n                        password: 'string',\n                        picture: 'binary',\n                        birthdate: 'date',\n                        gender: 'string',\n                        phone_number: 'string',\n                        samePassword: function(clearText) {\n                            var sha256 = crypto.createHash('sha256');\n                            sha256.update(clearText);\n                            return this.password == sha256.digest('hex');\n                        }\n                    },\n                    beforeCreate: function(values, next) {\n                        if(values.password) {\n                            if(values.password != values.passConfirm) {\n                                return next(\"Password and confirmation does not match\");\n                            }\n                            var sha256 = crypto.createHash('sha256');\n                            sha256.update(values.password);\n                            values.password = sha256.digest('hex');\n                        }\n                        next();\n                    },\n                    beforeUpdate: function(values, next) {\n                        if(values.password) {\n                            if(values.password != values.passConfirm) {\n                                return next(\"Password and confirmation does not match\");\n                            }\n                            var sha256 = crypto.createHash('sha256');\n                            sha256.update(values.password);\n                            values.password = sha256.digest('hex');\n                        }\n                        next();\n                    }\n                },\n                client: {\n                    identity: 'client',\n                    connection: 'def',\n                    schema: true,\n                    policies: 'loggedIn',\n                    attributes: {\n                        key: {type: 'string', required: true, unique: true},\n                        secret: {type: 'string', required: true, unique: true},\n                        name: {type: 'string', required: true},\n                        image: 'binary',\n                        user: {model: 'user'},\n                        redirect_uris: {type:'array', required: true},\n                        credentialsFlow: {type: 'boolean', defaultsTo: false}\n                    },\n                    beforeCreate: function(values, next) {\n                        if(!values.key) {\n                            var sha256 = crypto.createHash('sha256');\n                            sha256.update(values.name);\n                            sha256.update(Math.random()+'');\n                            values.key = sha256.digest('hex');\n                        }\n                        if(!values.secret) {\n                            var sha256 = crypto.createHash('sha256');\n                            sha256.update(values.key);\n                            sha256.update(values.name);\n                            sha256.update(Math.random()+'');\n                            values.secret = sha256.digest('hex');\n                        }\n                        next();\n                    }\n                },\n                consent: {\n                    identity: 'consent',\n                    connection: 'def',\n                    policies: 'loggedIn',\n                    attributes: {\n                        user: {model: 'user', required: true},\n                        client: {model: 'client', required: true},\n                        scopes: 'array'\n                    }\n                },\n                auth: {\n                    identity: 'auth',\n                    connection: 'def',\n                    policies: 'loggedIn',\n                    attributes: {\n                        client: {model: 'client',   required: true},\n                        scope: {type: 'array', required: true},\n                        user: {model: 'user', required: true},\n                        sub: {type: 'string', required: true},\n                        code: {type: 'string', required: true},\n                        redirectUri: {type: 'url', required: true},\n                        responseType: {type: 'string', required: true},\n                        status: {type: 'string', required: true},\n                        accessTokens: {\n                            collection: 'access',\n                            via: 'auth'\n                        },\n                        refreshTokens: {\n                            collection: 'refresh',\n                            via: 'auth'\n                        }\n                    }\n                },\n                access: {\n                    identity: 'access',\n                    connection: 'def',\n                    attributes: {\n                        token: {type: 'string', required: true},\n                        type: {type: 'string', required: true},\n                        idToken: 'string',\n                        expiresIn: 'integer',\n                        scope: {type: 'array', required: true},\n                        client: {model: 'client', required: true},\n                        user: {model: 'user', required: true},\n                        auth: {model: 'auth'}\n                    }\n                },\n                refresh: {\n                    identity: 'refresh',\n                    connection: 'def',\n                    attributes: {\n                        token: {type: 'string', required: true},\n                        scope: {type: 'array', required: true},\n                        auth: {model: 'auth', required: true},\n                        status: {type: 'string', required: true}\n                    }\n                }\n        }\n};\n\nfunction parse_authorization(authorization) {\n    if(!authorization)\n        return null;\n\n    var parts = authorization.split(' ');\n\n    if(parts.length != 2 || parts[0] != 'Basic')\n        return null;\n\n    var creds = new Buffer(parts[1], 'base64').toString(),\n    i = creds.indexOf(':');\n\n    if(i == -1)\n        return null;\n\n    var username = creds.slice(0, i);\n    password = creds.slice(i + 1);\n\n    return [username, password];\n}\n\nfunction OpenIDConnect(options) {\n    this.settings = extend(true, {}, defaults, options);\n\n    //allow removing attributes, by marking thme as null\n    cleanObj(this.settings.models, true);\n\n    for(var i in this.settings.policies) {\n        this.settings.policies[i] = this.settings.policies[i].bind(this);\n    }\n\n    if(this.settings.alien) {\n        for(var i in alien) {\n            if(this.settings.models[i]) delete this.settings.models[i];\n        }\n    }\n\n    if(this.settings.orm) {\n        this.orm = this.settings.orm;\n        for(var i in this.settings.policies) {\n            this.orm.setPolicy(true, i, this.settings.policies[i]);\n        }\n    } else {\n\n        this.orm = new modelling({\n            models: this.settings.models,\n            adapters: this.settings.adapters,\n            connections: this.settings.connections,\n            app: this.settings.app,\n            policies: this.settings.policies\n        });\n    }\n}\n\nOpenIDConnect.prototype = new EventEmitter();\n\nOpenIDConnect.prototype.done = function() {\n    this.orm.done();\n};\n\nOpenIDConnect.prototype.model = function(name) {\n    return this.orm.model(name);\n}\n\nOpenIDConnect.prototype.use = function(name) {\n    var alien = {};\n    if(this.settings.alien) {\n        var self = this;\n        if(!name) {\n            alien = this.settings.alien;\n        } else {\n            var m;\n            if(_.isPlainObject(name) && name.models) {\n                m = name.models;\n            }\n            if(util.isArray(m||name)) {\n                (m||name).forEach(function(model) {\n                    if(self.settings.alien[model]) {\n                        alien[model] = self.settings.alien[model];\n                    }\n                });\n            } else if(self.settings.alien[m||name]) {\n                alien[m||name] = self.settings.alien[m||name];\n            }\n        }\n    }\n    return [this.orm.use(name), function(req, res, next) {\n        extend(req.model, alien);\n        next();\n    }];\n};\n\nOpenIDConnect.prototype.getOrm = function() {\n    return this.orm;\n}\n/*OpenIDConnect.prototype.getClientParams = function() {\n    return this.orm.client.getParams();\n};*/\n\n/*OpenIDConnect.prototype.searchClient = function(parts, callback) {\n    return new this.orm.client.reverse(parts, callback);\n};\n\nOpenIDConnect.prototype.getUserParams = function() {\n    return this.orm.user.getParams();\n};\n\nOpenIDConnect.prototype.user = function(params, callback) {\n    return new this.orm.user(params, callback);\n};\n\nOpenIDConnect.prototype.searchUser = function(parts, callback) {\n    return new this.orm.user.reverse(parts, callback);\n};*/\n\nOpenIDConnect.prototype.errorHandle = function(res, uri, error, desc) {\n    if(uri) {\n        var redirect = url.parse(uri,true);\n        redirect.query.error = error; //'invalid_request';\n        redirect.query.error_description = desc; //'Parameter '+x+' is mandatory.';\n        res.redirect(400, url.format(redirect));\n    } else {\n        res.send(400, error+': '+desc);\n    }\n};\n\nOpenIDConnect.prototype.endpointParams = function (spec, req, res, next) {\n    try {\n        req.parsedParams = this.parseParams(req, res, spec);\n        next();\n    } catch(err) {\n        this.errorHandle(res, err.uri, err.error, err.msg);\n    }\n}\n\nOpenIDConnect.prototype.parseParams = function(req, res, spec) {\n    var params = {};\n    var r = req.param('redirect_uri');\n    for(var i in spec) {\n        var x = req.param(i);\n        if(x) {\n            params[i] = x;\n        }\n    }\n\n    for(var i in spec) {\n        var x = params[i];\n        if(!x) {\n            var error = false;\n            if(typeof spec[i] == 'boolean') {\n                error = spec[i];\n            } else if (_.isPlainObject(spec[i])) {\n                for(var j in spec[i]) {\n                    if(!util.isArray(spec[i][j])) {\n                        spec[i][j] = [spec[i][j]];\n                    }\n                    spec[i][j].forEach(function(e) {\n                        if(!error) {\n                            if(util.isRegExp(e)) {\n                                error = e.test(params[j]);\n                            } else {\n                                error = e == params[j];\n                            }\n                        }\n                    });\n                }\n            } else if (_.isFunction(spec[i])) {\n                error = spec[i](params);\n            }\n\n            if(error) {\n                throw {type: 'error', uri: r, error: 'invalid_request', msg: 'Parameter '+i+' is mandatory.'};\n                //this.errorHandle(res, r, 'invalid_request', 'Parameter '+i+' is mandatory.');\n                //return;\n            }\n        }\n    }\n    return params;\n};\n\n/**\n * login\n *\n * returns a function to be placed as middleware in connect/express routing methods. For example:\n *\n * app.post('/login', oidc.login(),  afterLogin, loginErrorHandler);\n *\n * This calls verification strategy and creates session.\n * Verification strategy must have two parameters: req and callback function with two parameters: error and user\n *\n *\n */\n\nOpenIDConnect.prototype.login = function(validateUser) {\n    var self = this;\n\n    return [self.use({policies: {loggedIn: false}, models: 'user'}),\n            function(req, res, next) {\n                validateUser(req, /*next:*/function(error,user) {\n                    if(!error && !user) {\n                        error = new Error('User not validated');\n                    }\n                    if(!error) {\n                        if(user.id) {\n                            req.session.user = user.id;\n                        } else {\n                            delete req.session.user;\n                        }\n                        if(user.sub) {\n                            if(typeof user.sub ==='function') {\n                                req.session.sub = user.sub();\n                            } else {\n                                req.session.sub = user.sub;\n                            }\n                        } else {\n                            delete req.session.sub;\n                        }\n                        return next();\n                    } else {\n                        return next(error);\n                    }\n                });\n    }];\n};\n\n/**\n * auth\n *\n * returns a function to be placed as middleware in connect/express routing methods. For example:\n *\n * app.get('/authorization', oidc.auth());\n *\n * This is the authorization endpoint, as described in http://tools.ietf.org/html/rfc6749#section-3.1\n *\n */\nOpenIDConnect.prototype.auth = function() {\n    var self = this;\n    var spec = {\n            response_type: true,\n            client_id: true,\n            scope: true,\n            redirect_uri: true,\n            state: false,\n            nonce: function(params){\n                return params.response_type.indexOf('id_token')!==-1;\n            },\n            display: false,\n            prompt: false,\n            max_age: false,\n            ui_locales: false,\n            claims_locales: false,\n            id_token_hint: false,\n            login_hint: false,\n            acr_values: false,\n            response_mode: false\n    };\n    return [function(req, res, next) {\n                self.endpointParams(spec, req, res, next);\n            },\n            self.use(['client', 'consent', 'auth', 'access']),\n            function(req, res, next) {\n                Q(req.parsedParams).then(function(params) {\n                    //Step 2: Check if response_type is supported and client_id is valid.\n\n                    var deferred = Q.defer();\n                    switch(params.response_type) {\n                    case 'none':\n                    case 'code':\n                    case 'token':\n                    case 'id_token':\n                        break;\n                    default:\n                        //var error = false;\n                        var sp = params.response_type.split(' ');\n                        sp.forEach(function(response_type) {\n                            if(['code', 'token', 'id_token'].indexOf(response_type) == -1) {\n                                throw {type: 'error', uri: params.redirect_uri, error: 'unsupported_response_type', msg: 'Response type '+response_type+' not supported.'};\n                            }\n                        });\n                    }\n                    req.model.client.findOne({key: params.client_id}, function(err, model) {\n                        if(err || !model || model === '') {\n                            deferred.reject({type: 'error', uri: params.redirect_uri, error: 'invalid_client', msg: 'Client '+params.client_id+' doesn\\'t exist.'});\n                        } else {\n                            req.session.client_id = model.id;\n                            req.session.client_secret = model.secret;\n                            deferred.resolve(params);\n                        }\n                    });\n\n                    return deferred.promise;\n                }).then(function(params){\n                    //Step 3: Check if scopes are valid, and if consent was given.\n\n                    var deferred = Q.defer();\n                    var reqsco = params.scope.split(' ');\n                    req.session.scopes = {};\n                    var promises = [];\n                    req.model.consent.findOne({user: req.session.user, client: req.session.client_id}, function(err, consent) {\n                            reqsco.forEach(function(scope) {\n                                var innerDef = Q.defer();\n                                if(!self.settings.scopes[scope]) {\n                                    innerDef.reject({type: 'error', uri: params.redirect_uri, error: 'invalid_scope', msg: 'Scope '+scope+' not supported.'});\n                                }\n                                if(!consent) {\n                                    req.session.scopes[scope] = {ismember: false, explain: self.settings.scopes[scope]};\n                                    innerDef.resolve(true);\n                                } else {\n                                    var inScope = consent.scopes.indexOf(scope) !== -1;\n                                    req.session.scopes[scope] = {ismember: inScope, explain: self.settings.scopes[scope]};\n                                    innerDef.resolve(!inScope);\n                                }\n                                promises.push(innerDef.promise);\n                            });\n\n                            Q.allSettled(promises).then(function(results){\n                                var redirect = false;\n                                for(var i = 0; i<results.length; i++) {\n                                    if(results[i].value) {\n                                        redirect = true;\n                                        break;\n                                    }\n                                }\n                                if(redirect) {\n                                    req.session.client_key = params.client_id;\n                                    var q = req.path+'?'+querystring.stringify(params);\n                                    deferred.reject({type: 'redirect', uri: self.settings.consent_url+'?'+querystring.stringify({return_url: q})});\n                                } else {\n                                    deferred.resolve(params);\n                                }\n                            });\n                    });\n\n                    return deferred.promise;\n                }).then(function(params){\n                    //Step 5: create responses\n                    if(params.response_type == 'none') {\n                        return {params: params, resp: {}};\n                    } else {\n                        var deferred = Q.defer();\n                        var promises = [];\n\n                        var rts = params.response_type.split(' ');\n\n                        rts.forEach(function(rt) {\n                            var def = Q.defer();\n                            promises.push(def.promise);\n                            switch(rt) {\n                            case 'code':\n                                var createToken = function() {\n                                    var token = crypto.createHash('md5').update(params.client_id).update(Math.random()+'').digest('hex');\n                                    req.model.auth.findOne({code: token}, function(err, auth){\n                                        if(!auth) {\n                                            setToken(token);\n                                        } else {\n                                            createToken();\n                                        }\n                                    });\n                                };\n                                var setToken = function(token) {\n                                    req.model.auth.create({\n                                        client: req.session.client_id,\n                                        scope: params.scope.split(' '),\n                                        user: req.session.user,\n                                        sub: req.session.sub||req.session.user,\n                                        code: token,\n                                        redirectUri: params.redirect_uri,\n                                        responseType: params.response_type,\n                                        status: 'created'\n                                    }).exec(function(err, auth) {\n                                        if(!err && auth) {\n                                            setTimeout(function() {\n                                                req.model.auth.findOne({code: token}, function(err, auth) {\n                                                    if(auth && auth.status == 'created') {\n                                                        auth.destroy();\n                                                    }\n                                                });\n                                            }, 1000*60*10); //10 minutes\n                                            def.resolve({code: token});\n                                        } else {\n                                            def.reject(err||'Could not create auth');\n                                        }\n                                    });\n\n                                };\n                                createToken();\n                                break;\n                            case 'id_token':\n                                var d = Math.round(new Date().getTime()/1000);\n                                //var id_token = {\n                                def.resolve({id_token: {\n                                        iss: req.protocol+'://'+req.headers.host,\n                                        sub: req.session.sub||req.session.user,\n                                        aud: params.client_id,\n                                        exp: d+3600,\n                                        iat: d,\n                                        nonce: params.nonce\n                                }});\n                                //def.resolve({id_token: jwt.encode(id_token, req.session.client_secret)});\n                                break;\n                            case 'token':\n                                var createToken = function() {\n                                    var token = crypto.createHash('md5').update(params.client_id).update(Math.random()+'').digest('hex');\n                                    req.model.access.findOne({token: token}, function(err, access) {\n                                        if(!access) {\n                                            setToken(token);\n                                        } else {\n                                            createToken();\n                                        }\n                                    });\n                                };\n                                var setToken = function(token) {\n                                    var obj = {\n                                            token: token,\n                                            type: 'Bearer',\n                                            expiresIn: 3600,\n                                            user: req.session.user,\n                                            client: req.session.client_id,\n                                            scope: params.scope.split(' ')\n                                    };\n                                    req.model.access.create(obj, function(err, access) {\n                                        if(!err && access) {\n                                            setTimeout(function() {\n                                                access.destroy();\n                                            }, 1000*3600); //1 hour\n\n                                            def.resolve({\n                                                access_token: obj.token,\n                                                token_type: obj.type,\n                                                expires_in: obj.expiresIn\n                                            });\n                                        }\n                                    });\n                                };\n                                createToken();\n                                break;\n                            }\n                        });\n\n                        Q.allSettled(promises).then(function(results) {\n                            var resp = {};\n                            for(var i in results) {\n                                resp = extend(resp, results[i].value||{});\n                            }\n                            if(resp.access_token && resp.id_token) {\n                                var hbuf = crypto.createHmac('sha256', req.session.client_secret).update(resp.access_token).digest();\n                                resp.id_token.at_hash = base64url(hbuf.toString('ascii', 0, hbuf.length/2));\n                                resp.id_token = jwt.encode(resp.id_token, req.session.client_secret);\n                            }\n                            deferred.resolve({params: params, type: params.response_type != 'code'?'f':'q', resp: resp});\n                        });\n\n                        return deferred.promise;\n                    }\n                })\n                .then(function(obj) {\n                    var params = obj.params;\n                    var resp = obj.resp;\n                    var uri = url.parse(params.redirect_uri, true);\n                    if(params.state) {\n                        resp.state = params.state;\n                    }\n                    if(params.redirect_uri) {\n                        if(obj.type == 'f') {\n                            uri.hash = querystring.stringify(resp);\n                        } else {\n                            uri.query = resp;\n                        }\n                        res.redirect(url.format(uri));\n                    }\n                })\n                .fail(function(error) {\n                    if(error.type == 'error') {\n                        self.errorHandle(res, error.uri, error.error, error.msg);\n                    } else {\n                        res.redirect(error.uri);\n                    }\n                });\n            }\n            ];\n};\n\n/**\n * consent\n *\n * returns a function to be placed as middleware in connect/express routing methods. For example:\n *\n * app.post('/consent', oidc.consent());\n *\n * This method saves the consent of the resource owner to a client request, or returns an access_denied error.\n *\n */\nOpenIDConnect.prototype.consent = function() {\n    var self = this;\n    return [self.use('consent'),\n    function(req, res, next) {\n        var accept = req.param('accept');\n        var return_url = req.param('return_url');\n        //var client_id = req.query.client_id || req.body.client_id || false;\n        if(accept) {\n            var scopes = [];\n            for(var i in req.session.scopes) {\n                scopes.push(i);\n            }\n            req.model.consent.destroy({user: req.session.user, client: req.session.client_id}, function(err, result) {\n                req.model.consent.create({user: req.session.user, client: req.session.client_id, scopes: scopes}, function(err, consent) {\n                    res.redirect(return_url);\n                });\n            });\n        } else {\n            var returl = url.parse(return_url, true);\n            var redirect_uri = returl.query.redirect_uri;\n            self.errorHandle(res, redirect_uri, 'access_denied', 'Resource Owner denied Access.');\n        }\n    }];\n};\n\n\n/**\n * token\n *\n * returns a function to be placed as middleware in connect/express routing methods. For example:\n *\n * app.get('/token', oidc.token());\n *\n * This is the token endpoint, as described in http://tools.ietf.org/html/rfc6749#section-3.2\n *\n */\nOpenIDConnect.prototype.token = function() {\n    var self = this;\n    var spec = {\n            grant_type: true,\n            code: false,\n            redirect_uri: false,\n            refresh_token: false,\n            scope: false\n    };\n\n    return [\n        function(req, res, next) {\n            self.endpointParams(spec, req, res, next)\n        },\n\n        self.use({policies: {loggedIn: false}, models:['client', 'consent', 'auth', 'access', 'refresh']}),\n\n        function(req, res, next) {\n            var params = req.parsedParams;\n\n            var client_key = req.body.client_id;\n            var client_secret = req.body.client_secret;\n\n            if(!client_key || !client_secret) {\n                var authorization = parse_authorization(req.headers.authorization);\n                if(authorization) {\n                    client_key = authorization[0];\n                    client_secret = authorization[1];\n                }\n            }\n            if(!client_key || !client_secret) {\n                self.errorHandle(res, params.redirect_uri, 'invalid_client', 'No client credentials found.');\n            } else {\n\n                Q.fcall(function() {\n                    //Step 2: check if client and secret are valid\n                    var deferred = Q.defer();\n                    req.model.client.findOne({key: client_key, secret: client_secret}, function(err, client){\n                        if(err || !client) {\n                            deferred.reject({type: 'error', error: 'invalid_client', msg: 'Client doesn\\'t exist or invalid secret.'});\n                        } else {\n                            deferred.resolve(client);\n                        }\n                    });\n                    return deferred.promise;\n                })\n                .then(function(client) {\n\n                    var deferred = Q.defer();\n\n                    switch(params.grant_type) {\n                    //Client is trying to exchange an authorization code for an access token\n                    case \"authorization_code\":\n                        //Step 3: check if code is valid and not used previously\n                        req.model.auth.findOne({code: params.code})\n                        .populate('accessTokens')\n                        .populate('refreshTokens')\n                        .populate('client')\n                        .exec(function(err, auth) {\n                            if(!err && auth) {\n                                if(auth.status != 'created') {\n                                    auth.refresh.forEach(function(refresh) {\n                                        refresh.destroy();\n                                    });\n                                    auth.access.forEach(function(access) {\n                                        access.destroy();\n                                    });\n                                    auth.destroy();\n                                    deferred.reject({type: 'error', error: 'invalid_grant', msg: 'Authorization code already used.'});\n                                } else {\n                                    //obj.auth = a;\n                                    deferred.resolve({auth: auth, scope: auth.scope, client: client, user: auth.user, sub: auth.sub});\n                                }\n                            } else {\n                                deferred.reject({type: 'error', error: 'invalid_grant', msg: 'Authorization code is invalid.'});\n                            }\n                        });\n\n                        //Extra checks, required if grant_type is 'authorization_code'\n                        return deferred.promise.then(function(obj){\n                            //Step 4: check if grant_type is valid\n\n                            if(obj.auth.responseType != 'code') {\n                                throw {type: 'error', error: 'unauthorized_client', msg: 'Client cannot use this grant type.'};\n                            }\n\n                            //Step 5: check if redirect_uri is valid\n                            if((obj.auth.redirectUri || params.redirect_uri) && obj.auth.redirectUri != params.redirect_uri) {\n                                throw {type: 'error', error: 'invalid_grant', msg: 'Redirection URI does not match.'};\n                            }\n\n                            return obj;\n                        });\n\n                        break;\n\n                        //Client is trying to exchange a refresh token for an access token\n                    case \"refresh_token\":\n\n                        //Step 3: check if refresh token is valid and not used previously\n                        req.model.refresh.findOne({token: params.refresh_token}, function(err, refresh) {\n                            if(!err && refresh) {\n                                req.model.auth.findOne({id: refresh.auth})\n\t                            .populate('accessTokens')\n\t                            .populate('refreshTokens')\n                                .populate('client')\n                                .exec(function(err, auth) {\n                                    if(refresh.status != 'created') {\n                                        auth.access.forEach(function(access){\n                                            access.destroy();\n                                        });\n                                        auth.refresh.forEach(function(refresh){\n                                            refresh.destroy();\n                                        });\n                                        auth.destroy();\n                                        deferred.reject({type: 'error', error: 'invalid_grant', msg: 'Refresh token already used.'});\n                                    } else {\n                                        refresh.status = 'used';\n                                        refresh.save();\n                                        deferred.resolve({auth: auth, client: client, user: auth.user, sub: auth.sub});\n                                    }\n                                });\n                            } else {\n                                deferred.reject({type: 'error', error: 'invalid_grant', msg: 'Refresh token is not valid.'});\n                            }\n                        });\n                        return deferred.promise.then(function(obj){\n                            if(params.scope) {\n                                var scopes = params.scope.split(' ');\n                                if(scopes.length) {\n                                    scopes.forEach(function(scope) {\n                                        if(obj.auth.scope.indexOf(scope) == -1) {\n                                            throw {type: 'error', uri: params.redirect_uri, error: 'invalid_scope', msg: 'Scope '+scope+' was not granted for this token.'};\n                                        }\n                                    });\n                                    obj.scope = scopes;\n                                }\n                            } else {\n                                obj.scope = obj.auth.scope;\n                            }\n\n                            return obj;\n                        });\n                        break;\n                    case 'client_credentials':\n                        if(!client.credentialsFlow) {\n                            deferred.reject({type: 'error', error: 'unauthorized_client', msg: 'Client cannot use this grant type.'});\n                        } else {\n                            deferred.resolve({scope: params.scope, auth: false, client: client});\n                        }\n                        return deferred.promise;\n                        break;\n                    }\n\n                })\n                .then(function(obj) {\n                    //Check if code was issued for client\n                    if(params.grant_type != 'client_credentials' && obj.auth.client.key != client_key) {\n                        throw {type: 'error', error: 'invalid_grant', msg: 'The code was not issued for this client.'};\n                    }\n\n                    return obj;\n\n                })\n                .then(function(prev){\n                    //Create access token\n                    /*var scopes = obj.scope;\n                    var auth = obj.auth;*/\n\n                    var createToken = function(model, cb) {\n                        var token = crypto.createHash('md5').update(Math.random()+'').digest('hex');\n                        model.findOne({token: token}, function(err, response) {\n                            if(!response) {\n                                cb(token);\n                            } else {\n                                createToken(model, cb);\n                            }\n                        });\n                    };\n                    var setToken = function(access, refresh) {\n                        req.model.refresh.create({\n                            token: refresh,\n                            scope: prev.scope,\n                            status: 'created',\n                            auth: prev.auth?prev.auth.id:null\n                        },\n                        function(err, refresh) {\n                            setTimeout(function() {\n                                refresh.destroy();\n                                if(refresh.auth) {\n                                    req.model.auth.findOne({id: refresh.auth})\n\t\t                            .populate('accessTokens')\n\t\t                            .populate('refreshTokens')\n                                    .exec(function(err, auth) {\n                                        if(auth && !auth.access.length && !auth.refresh.length) {\n                                            auth.destroy();\n                                        }\n                                    });\n                                }\n                            }, 1000*3600*5); //5 hours\n\n                            var d = Math.round(new Date().getTime()/1000);\n                            var id_token = {\n                                    iss: req.protocol+'://'+req.headers.host,\n                                    sub: prev.sub||prev.user||null,\n                                    aud: prev.client.key,\n                                    exp: d+3600,\n                                    iat: d\n                            };\n                            req.model.access.create({\n                                    token: access,\n                                    type: 'Bearer',\n                                    expiresIn: 3600,\n                                    user: prev.user||null,\n                                    client: prev.client.id,\n                                    idToken: jwt.encode(id_token, prev.client.secret),\n                                    scope: prev.scope,\n                                    auth: prev.auth?prev.auth.id:null\n                            },\n                            function(err, access) {\n                                if(!err && access) {\n                                    if(prev.auth) {\n                                        prev.auth.status = 'used';\n                                        prev.auth.save();\n                                    }\n\n                                    setTimeout(function() {\n                                        access.destroy();\n                                        if(access.auth) {\n                                            req.model.auth.findOne({id: access.auth})\n\t\t\t\t                            .populate('accessTokens')\n\t\t\t\t                            .populate('refreshTokens')\n                                            .exec(function(err, auth) {\n                                                if(auth && !auth.access.length && !auth.refresh.length) {\n                                                    auth.destroy();\n                                                }\n                                            });\n                                        }\n                                    }, 1000*3600); //1 hour\n\n                                    res.json({\n                                        access_token: access.token,\n                                        token_type: access.type,\n                                        expires_in: access.expiresIn,\n                                        refresh_token: refresh.token,\n                                        id_token: access.idToken\n                                    });\n                                }\n                            });\n                        });\n                    };\n                    createToken(req.model.access, function(access) {\n                        createToken(req.model.refresh, function(refresh){\n                            setToken(access, refresh);\n                        });\n                    });\n                })\n                .fail(function(error) {\n                    if(error.type == 'error') {\n                        self.errorHandle(res, params.redirect_uri, error.error, error.msg);\n                    } else {\n                        res.redirect(error.uri);\n                    }\n                });\n            }\n    }];\n};\n\n\n/**\n * check\n *\n * returns a function to be placed as middleware in connect/express routing methods. For example:\n *\n * app.get('/api/user', oidc.check('openid', /profile|email/), function(req, res, next) { ... });\n *\n * If no arguments are given, checks if access token is valid.\n *\n * The other arguments may be of type string or regexp.\n *\n * This function is used to check if user logged in, if an access_token is present, and if certain scopes where granted to it.\n */\nOpenIDConnect.prototype.check = function() {\n    //Seguir desde ac√°!!!!\n    var scopes = Array.prototype.slice.call(arguments, 0);\n    if(!util.isArray(scopes)) {\n        scopes = [scopes];\n    }\n    var self = this;\n    spec = {\n            access_token: false\n    };\n\n    return [\n        function(req, res, next) {\n            self.endpointParams(spec, req, res, next);\n        },\n        self.use({policies: {loggedIn: false}, models:['access', 'auth']}),\n        function(req, res, next) {\n            var params = req.parsedParams;\n            if(!scopes.length) {\n                next();\n            } else {\n                if(!params.access_token) {\n                    params.access_token = (req.headers['authorization'] || '').indexOf('Bearer ') === 0 ? req.headers['authorization'].replace('Bearer', '').trim() : false;\n                }\n                if(params.access_token) {\n                    req.model.access.findOne({token: params.access_token})\n                    .exec(function(err, access) {\n                        if(!err && access) {\n                                var errors = [];\n\n                                scopes.forEach(function(scope) {\n                                    if(typeof scope == 'string') {\n                                        if(access.scope.indexOf(scope) == -1) {\n                                            errors.push(scope);\n                                        }\n                                    } else if(util.isRegExp(scope)) {\n                                        var inS = false;\n                                        access.scope.forEach(function(s){\n                                            if(scope.test(s)) {\n                                                inS = true;\n                                            }\n                                        });\n                                        !inS && errors.push('('+scope.toString().replace(/\\//g,'')+')');\n                                    }\n                                });\n                                if(errors.length > 1) {\n                                    var last = errors.pop();\n                                    self.errorHandle(res, null, 'invalid_scope', 'Required scopes '+errors.join(', ')+' and '+last+' where not granted.');\n                                } else if(errors.length > 0) {\n                                    self.errorHandle(res, null, 'invalid_scope', 'Required scope '+errors.pop()+' not granted.');\n                                } else {\n                                    req.check = req.check||{};\n                                    req.check.scopes = access.scope;\n                                    next();\n                                }\n                        } else {\n                            self.errorHandle(res, null, 'unauthorized_client', 'Access token is not valid.');\n                        }\n                    });\n                } else {\n                    self.errorHandle(res, null, 'unauthorized_client', 'No access token found.');\n                }\n            }\n        }\n    ];\n};\n\n/**\n * userInfo\n *\n * returns a function to be placed as middleware in connect/express routing methods. For example:\n *\n * app.get('/api/user', oidc.userInfo());\n *\n * This function returns the user info in a json object. Checks for scope and login are included.\n */\nOpenIDConnect.prototype.userInfo = function() {\n    var self = this;\n    return [\n            self.check('openid', /profile|email/),\n            self.use({policies: {loggedIn: false}, models: ['access', 'user']}),\n            function(req, res, next) {\n                req.model.access.findOne({token: req.parsedParams.access_token})\n                .exec(function(err, access) {\n                    if(!err && access) {\n                        req.model.user.findOne({id: access.user}, function(err, user) {\n                            if(req.check.scopes.indexOf('profile') != -1) {\n                                user.sub = req.session.sub||req.session.user;\n                                delete user.id;\n                                delete user.password;\n                                delete user.openidProvider;\n                                res.json(user);\n                            } else {\n                                res.json({email: user.email});\n                            }\n                        });\n                    } else {\n                        self.errorHandle(res, null, 'unauthorized_client', 'Access token is not valid.');\n                    }\n                });\n    }];\n};\n\n/**\n * removetokens\n *\n * returns a function to be placed as middleware in connect/express routing methods. For example:\n *\n * app.get('/logout', oidc.removetokens(), function(req, res, next) { ... });\n *\n * this function removes all tokens that were issued to the user\n * access_token is required either as a parameter or as a Bearer token\n */\nOpenIDConnect.prototype.removetokens = function() {\n    var self = this,\n        spec = {\n            access_token: false //parameter not mandatory\n        };\n\n    return [\n            function(req, res, next) {\n                self.endpointParams(spec, req, res, next);\n            },\n            self.use({policies: {loggedIn: false}, models: ['access','auth']}),\n            function(req, res, next) {\n                var params = req.parsedParams;\n\n                if(!params.access_token) {\n                    params.access_token = (req.headers['authorization'] || '').indexOf('Bearer ') === 0 ? req.headers['authorization'].replace('Bearer', '').trim() : false;\n                }\n                if(params.access_token) {\n                    //Delete the provided access token, and other tokens issued to the user\n                    req.model.access.findOne({token: params.access_token})\n                    .exec(function(err, access) {\n                        if(!err && access) {\n                            req.model.auth.findOne({user: access.user})\n                            .populate('accessTokens')\n                            .populate('refreshTokens')\n                            .exec(function(err, auth) {\n                                if(!err && auth) {\n                                    auth.accessTokens.forEach(function(access){\n                                        access.destroy();\n                                    });\n                                    auth.refreshTokens.forEach(function(refresh){\n                                        refresh.destroy();\n                                    });\n                                    auth.destroy();\n                                };\n                                req.model.access.find({user:access.user})\n                                .exec(function(err,accesses){\n                                    if(!err && accesses) {\n                                        accesses.forEach(function(access) {\n                                            access.destroy();\n                                        });\n                                    };\n                                    return next();\n                                });\n                            });\n                        } else {\n                            self.errorHandle(res, null, 'unauthorized_client', 'Access token is not valid.');\n                        }\n                    });\n                } else {\n                    self.errorHandle(res, null, 'unauthorized_client', 'No access token found.');\n                }\n            }\n            ];\n};\n\nexports.oidc = function(options) {\n    return new OpenIDConnect(options);\n};\n\nexports.defaults = function() {\n    return defaults;\n}\n"}